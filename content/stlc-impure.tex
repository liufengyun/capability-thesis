\section{System STLC-Impure}

This chapter describes an extension of the system STLC-Pure with free
functions. As there's a subtyping between the stoic functions and free
functions, it's natural to integrate subtyping in the system.

We'll first introduce the formalization, then discuss soundness and
effect safety. In the discussion, we'll focus on its difference from
system STLC-Pure.

\subsection{Definitions}

Initially, we arrived at a formualtion of the system shown in
Figure~\ref{fig:stlc-impure-definition-first}. It's a straight-forward
extension of SLTC-Pure with subtyping and free functions.

The definition is all good, except that perservation breaks! The
problem is caused by using an impure term as \emph{Top}. To see a
concrete example, let's assume $\Gamma = \{c:E\}$. It's obvious that
following term is well-typed under $\Gamma$ as $B \to Top$:

\begin{center}
  $(\lambda x:Top. \; \lambda y:B. \; x) \; c$
\end{center}

However, after one evaluation step\footnote{Note that variables are
  values, thus we can take a step here. We can also construct a
  counter-example by wrap $c$ in a free function like
  $\lambda x:B. c$.}, we get the term $\lambda y:B. \; c$, which can
at best be typed as $B \Rightarrow Top$. Thus preservation doesn't
hold in current formulation. This problem leads us to two different
formuations.

\begin{figure}
\begin{framed}

% multi-column separator
\setlength{\columnseprule}{0.4pt}
\begin{multicols}{2}

\textbf{Syntax}

\begin{tabu} to \linewidth {l l l X[r]}
  t   & ::= &                    & terms:               \\
      &     &  x                 & variable             \\
      &     & $\lambda$ x:T.t    & abstraction          \\
      &     & t t                & application          \\
\\
  v   & ::= &                    & values:              \\
      &     & $\lambda$ x:T.t    & abstraction value    \\
      &     & x                  & variable value       \\
\\
  T   & ::= &                    & types:               \\
      &     & \colorbox{shade}{Top}  & top type             \\
      &     & B                  & basic type           \\
      &     & E                  & capability type      \\
      &     & T $\to$ T          & type of stoic funs       \\
      &     & \colorbox{shade}{T $\Rightarrow$ T} & type of free funs   \\
\end{tabu}

\hfill\\

\textbf{Evaluation} \hfill \framebox[1.2\width][r]{$t \longrightarrow t'$}

\infrule[E-App1]
{ t_1 \longrightarrow t'_1 }
{ t_1 \; t_2 \longrightarrow t'_1 \; t_2 }

\infrule[E-App2]
{ t_2 \longrightarrow t'_2 }
{ v_1 \; t_2 \longrightarrow v_1 \; t'_2 }

\infax[E-AppAbs]
{ (\lambda x:T.t_1) v_2 \longrightarrow [x \mapsto v_2]t_1 }

\textbf{Pure Environment}

\hfill

\begin{center}
\begin{tabular}{l c l}
pure($\varnothing$)                   & = &   $\varnothing$ \\
pure($\Gamma$, x: E)                  & = &  pure($\Gamma$) \\
\rowcolor{gray!40}
pure($\Gamma$, x: S $\Rightarrow$ T)  & = &  pure($\Gamma$) \\
pure($\Gamma$, x: T)                  & = &  pure($\Gamma$), x: T     \\
\end{tabular}
\end{center}

\columnbreak

\textbf{Typing}  \hfill \framebox[1.2\width][r]{$\Gamma \vdash x : T$}

\infrule[T-Var]
{ x: T \in \Gamma }
{ \Gamma \vdash x : T }

\infrule[T-Abs1]
{ pure(\Gamma),\; x: S \vdash t_2 : T }
{ \Gamma \vdash \lambda x:S.t_2 : S \to T }

\infrule[T-Abs2]
{  \colorbox{shade}{$\Gamma,\; x: S \vdash t_2 : T$} }
{  \colorbox{shade}{$\Gamma \vdash \lambda x:S.t_2 : S \Rightarrow T$} }

\infrule[T-App]
{ \Gamma \vdash t_1 : S \to T \andalso \Gamma \vdash t_2 : S }
{ \Gamma \vdash t_1 \; t_2 : T }

\infrule[T-Sub]
{  \colorbox{shade}{$\Gamma \vdash t : S \andalso S <: T$} }
{  \colorbox{shade}{$\Gamma \vdash t : T$} }

\colorbox{shade}{\textbf{Subtyping}}  \hfill \framebox[1.2\width][r]{$S <: T$}

\infax[S-Top]{ T <: Top }

\infax[S-Refl]{ T <: T }

\infrule[S-Trans]
{ S <: U \andalso U <: T }
{ S <: T }

\infrule[S-Degen]
{ S \to T }
{ S \Rightarrow T }

\infrule[S-Fun1]
{ S1 <: S2 \andalso T2 <: T1 }
{ S2 \to T2 <: S1 \to T1 }

\infrule[S-Fun2]
{ S1 <: S2 \andalso T2 <: T1 }
{ S2 \Rightarrow T2 <: S1 \Rightarrow T1 }

\hfill\\

\end{multicols}
\end{framed}

\caption{System STLC-Impure First Formulation}
\label{fig:stlc-impure-definition-first}
\end{figure}

The first one is to introduce two different Top types, one is pure and
the other is impure\footnote{This idea is suggested by Sandro
  Stucki.}. The capability type E and free function type
$S \Rightarrow T$ are not sutype of the pure Top. The subtyping
hierarchy is shown in
Figure~\ref{fig:stlc-impure-subtyping-tree}. This formulation works
well, and we've proved soundness and effect safety for the
formulation. However, we lose the simplicity of the type system. And
it's counter-intuitive to forbid Top in pure environments, as we
cannot create side effects with a variable of the type Top.

\begin{figure}
\centering

\begin{tikzpicture}[sibling distance=5em,
  every node/.style = {align=center},
  edge from parent/.style={draw,latex-}]
  \node {Top-Impure}
  child { node {E} }
  child { node (free) {S $\Rightarrow$ T} }
  child { node {Top-Pure}
    child { node (stoic) {S $\to$ T} }
    child { node {B} } };
  \path [draw, -latex] (stoic) -- (free);
\end{tikzpicture}

\caption{Subtyping: Top-Pure and Top-Impure}
\label{fig:stlc-impure-subtyping-tree}
\end{figure}

The second possibility is to keep the elegance of the type system and
changes the evaluation rules. We know that all terms of the type Top
are equivalent, because we can do nothing with a term of type Top. It
implies we can substitute them arbitrarily without changing the
meaning of the term. This observation inspires us to introduce a
\emph{top} value and change the standard \textsc{E-AppAbs} rule to two
evaluation rules as follows:

\infrule[E-AppAbs1]
{ T \neq Top }
{ (\lambda x:T.t_1) v_2 \longrightarrow [x \mapsto v_2]t_1 }

\infrule[E-AppAbs2]
{ T = Top }
{ (\lambda x:T.t_1) v_2 \longrightarrow [x \mapsto top]t_1 }

The two rules have the effect that if a function takes a parameter of
type Top, then when called it will drop the parameter and replace it
with the \emph{top} value. We follow this approach in the formulation
and the full definition is presented in
Figure~\ref{fig:stlc-impure-definition}.

\begin{figure}
\begin{framed}

% multi-column separator
\setlength{\columnseprule}{0.4pt}
\begin{multicols}{2}

\textbf{Syntax}

\begin{tabu} to \linewidth {l l l X[r]}
  t   & ::= &                    & terms:               \\
      &     & \colorbox{shade}{top} & top value            \\
      &     & x                  & variable             \\
      &     & $\lambda$ x:T.t    & abstraction          \\
      &     & t t                & application          \\
\\
  v   & ::= &                    & values:              \\
      &     & $\lambda$ x:T.t    & abstraction value    \\
      &     & x                  & variable value       \\
      &     & \colorbox{shade}{top}  & top value            \\
\\
  T   & ::= &                    & types:               \\
      &     & \colorbox{shade}{Top}  & top type             \\
      &     & B                  & basic type           \\
      &     & E                  & capability type      \\
      &     & T $\to$ T          & type of stoic funs       \\
      &     & \colorbox{shade}{T $\Rightarrow$ T} & type of free funs   \\
\end{tabu}

% \hfill\\
\vspace{0.1em}

\textbf{Evaluation} \hfill \framebox[1.2\width][r]{$t \longrightarrow t'$}

\infrule[E-App1]
{ t_1 \longrightarrow t'_1 }
{ t_1 \; t_2 \longrightarrow t'_1 \; t_2 }

\infrule[E-App2]
{ t_2 \longrightarrow t'_2 }
{ v_1 \; t_2 \longrightarrow v_1 \; t'_2 }

\infrule[E-AppAbs1]
{ \colorbox{shade}{$T \neq Top$} }
{ \colorbox{shade}{$(\lambda x:T.t_1) \; v_2 \longrightarrow [x \mapsto v_2]t_1$} }

\infrule[E-AppAbs2]
{ \colorbox{shade}{$T = Top$} }
{ \colorbox{shade}{$(\lambda x:T.t_1) \; v_2 \longrightarrow [x \mapsto top]t_1$} }

\textbf{Pure Environment}

\hfill

\begin{center}
\begin{tabular}{l c l}
pure($\varnothing$)                   & = &   $\varnothing$ \\
pure($\Gamma$, x: E)                  & = &  pure($\Gamma$) \\
\rowcolor{gray!40}
pure($\Gamma$, x: S $\Rightarrow$ T)  & = &  pure($\Gamma$) \\
pure($\Gamma$, x: T)                  & = &  pure($\Gamma$), x: T     \\
\end{tabular}
\end{center}

\columnbreak

\textbf{Typing}  \hfill \framebox[1.2\width][r]{$\Gamma \vdash x : T$}

\infax[T-Top]{ \colorbox{shade}{$\Gamma \vdash top : Top$} }

\infrule[T-Var]
{ x: T \in \Gamma }
{ \Gamma \vdash x : T }

\infrule[T-Abs1]
{ pure(\Gamma),\; x: S \vdash t_2 : T }
{ \Gamma \vdash \lambda x:S.t_2 : S \to T }

\infrule[T-Abs2]
{  \colorbox{shade}{$\Gamma,\; x: S \vdash t_2 : T$} }
{  \colorbox{shade}{$\Gamma \vdash \lambda x:S.t_2 : S \Rightarrow T$} }

\infrule[T-App]
{ \Gamma \vdash t_1 : S \to T \andalso \Gamma \vdash t_2 : S }
{ \Gamma \vdash t_1 \; t_2 : T }

\infrule[T-Sub]
{  \colorbox{shade}{$\Gamma \vdash t : S \andalso S <: T$} }
{  \colorbox{shade}{$\Gamma \vdash t : T$} }

\colorbox{shade}{\textbf{Subtyping}}  \hfill \framebox[1.2\width][r]{$S <: T$}

\infax[S-Top]{ T <: Top }

\infax[S-Refl]{ T <: T }

\infrule[S-Trans]
{ S <: U \andalso U <: T }
{ S <: T }

\infrule[S-Degen]
{ S \to T }
{ S \Rightarrow T }

\infrule[S-Fun1]
{ S1 <: S2 \andalso T2 <: T1 }
{ S2 \to T2 <: S1 \to T1 }

\infrule[S-Fun2]
{ S1 <: S2 \andalso T2 <: T1 }
{ S2 \Rightarrow T2 <: S1 \Rightarrow T1 }

\hfill\\

\end{multicols}
\end{framed}

\caption{System STLC-Impure}
\label{fig:stlc-impure-definition}
\end{figure}

Note that in this formulation, we need to change the definition of the
function \emph{pure} to exclude free function types in the pure
environment. This restriction is important, because we're not sure
what side effects there might be inside free functions. If we allow
stoic functions to have access to free functions, we'll loose the
ability to track the effects of stoic functions in the type system.

In principle, we can keep some free functions that we are sure can
never be called in the pure environment, such as
$(B \to E) \Rightarrow B$, as it's impossible to get an actual
instance of the type $B \to E$ in order to call this
function. However, from the perspective of practicity, it doesn't make
sense to have functions in the environment if they can never be
called. Thus, to simplify the system without sacrificing usability, we
removed all free function types from the pure environment.

\subsection{Soundness}

We proved both progress and preservation in Coq based on the
locally-nameless representation.

\begin{theorem}[Progress]
If $\varnothing \vdash t : T$, then either $t$ is a value or there is some
$t'$ with $t \longrightarrow t'$.
\end{theorem}

\begin{theorem}[Preservation]
If $\Gamma \vdash t : T$, and $t \longrightarrow t'$, then $\Gamma
\vdash t' : T$.
\end{theorem}

As you can imagine, now we need two different substitution lemmas in
the proof of perservation, corresponding to the two reduction rules.

\begin{lemma}[Subsitution-Not-Top]
  If $\Gamma,\; x:S \vdash t : T$, $S \neq Top$, s is a value and
  $\Gamma \vdash s : S$, then $\Gamma \vdash [x \mapsto s]t : T$.
\end{lemma}

\begin{lemma}[Subsitution-Top]
  If $\Gamma,\; x:Top \vdash t : T$, then $\Gamma \vdash [x \mapsto top]t : T$.
\end{lemma}

The reason why we restrict $s$ to be a value in the lemma
\emph{Substitution-Not-Top} is the same as we've seen in the system
STLC-Pure, thus we don't reiterate here.

\subsection{Effect Safety}

We follow the same approach as in the system STLC-Pure in the
formulation of effect safety. The formulation is an extension of the
definition of \emph{capsafe} and \emph{caprod} in STLC-Pure with free
function types.

\subsubsection{Formulation}

With the presence of free functions, the previous formulation of
effect safety is not enough. We not only need to ensure that it's
impossible to construct a term of the capability type in inhabitable
environments, but also need to ensure only stoic functions can be
called in inhabitable environments. The two conditions together
guarantee that there cannot be actual side effects inside a pure stoic
function. Thus, we need two statements about effect safety.

\begin{definition}[Effect-Safety-Inhabitability-1]
  If $\Gamma$ is a pure environment with only variables of inhabitable
  types, then there doesn't exist $t$ with $\Gamma \vdash t : E$.
\end{definition}

\begin{definition}[Effect-Safety-Inhabitability-2]
  If $\Gamma$ is a pure environment with only variables of inhabitable
  types, $\Gamma \vdash t_1 \; t_2 : T$, then there exists U, V such
  that $\Gamma \vdash t_1 : U \to V$.
\end{definition}

A tempting formulation of the second effect safety statement would be
that in an inhabitable environment it's impossible to construct a term
of the free function type. However, this formulation has no hope to be
proved, as $S \to T$ is a subtype of $S \Rightarrow T$, any term that
can be typed as the former can also be typed as the latter.

As in the system STLC-Pure, the proof of these two statements depends
on a weaker and more general statement about \emph{healthy
  environments}. If we can arrive at such a definition of
\emph{healthy environment} that a pure environment with only variables
of inhabitable types is also healthy, then it suffices to prove
following two statements about healthy environments:

\begin{definition}[Effect-Safety-1]
  If $\Gamma$ is healthy, there doesn't exist $t$ with
  $\Gamma \vdash t : E$.
\end{definition}

\begin{definition}[Effect-Safety-2]
  If $\Gamma$ is healthy and $\Gamma \vdash t_1 \; t_2 : T$, then
  there exists U, V such that $\Gamma \vdash t_1 : U \to V$.
\end{definition}

Now we need to extend the definition of \emph{capsafe} and
\emph{caprod} for free function types. Our first attempt is to add
following rule:

\infax[CP-Fun2]{ S \Rightarrow T \quad caprod }

With this rule, the type $(B \Rightarrow B) \to E$ would be considered
\emph{capsafe}, according to the \textsc{CS-Fun1} rule. However, with
a variable $f$ of this type in the healthy environment, together with
another variable $g$ of the \emph{capsafe} type $B \to B$, it's
possible to create the term \emph{f g}, which is of the capability
type E -- the first statement of effect safety breaks. This
formulation also breaks the connection between pure inhabitable
environments and healthy environments. In STLC-Pure, any inhabitable
type T is either \emph{capsafe} or $T = E$. But in current
formulation, the inhabitable type $B \to B \Rightarrow B$ is not
\emph{capsafe}!

On ther other hand, we can't do the opposite to take $S \Rightarrow T$
as \emph{capsafe}, as it would allow calling free functions in healthy
environments -- the second statement of effect safety breaks. In the
meanwhile, the inhabitable type $(B \Rightarrow E) \to E$ becomes
\emph{caprod}, thus it also breaks the connection between pure
inhabitable environments and healthy environments.

This dilemma prompts us to reexamin the meaning of \emph{capsafe} and
\emph{caprod}. When these facilities were first introduced in
STLC-Pure, they were formulated in terms of the provability of the
capability type E. From the perspective of provability of E, $S \to T$
and $S \Rightarrow T$ don't make much difference. Thus, free functions
types should be formulated the same way as sotic function types. We
tried this approach, and it worked. The full formulation is presented
in Figure~\ref{fig:stlc-impure-healthy-definition}.

\begin{figure}[h]
\begin{framed}

% multi-column separator
\setlength{\columnseprule}{0.4pt}
\begin{multicols}{2}

\textbf{Capsafe}

\infax[CS-Base]
{ B \quad \text{capsafe} }

\infrule[CS-Fun1]
{ S \quad caprod }
{ S \to T \quad \text{capsafe} }

\infrule[CS-Fun2]
{ T \quad \text{capsafe} }
{ S \to T \quad \text{capsafe} }

\infrule[CS-Fun3]
{ \colorbox{shade}{$S \quad caprod$} }
{ \colorbox{shade}{$S \Rightarrow T \quad \text{capsafe}$} }

\infrule[CS-Fun4]
{ \colorbox{shade}{$T \quad \text{capsafe}$} }
{ \colorbox{shade}{$S \Rightarrow T \quad \text{capsafe}$} }

\columnbreak

\textbf{Caprod}

\infax[CP-Eff]
{ E \quad caprod }

\infrule[CP-Fun1]
{ S \; \text{capsafe} \andalso T \; caprod }
{ S \to T \quad caprod }

\infrule[CP-Fun2]
{ \colorbox{shade}{$S \; \text{capsafe} \andalso T \; caprod$} }
{ \colorbox{shade}{$S \Rightarrow T \quad caprod$} }

\textbf{Healthy}

\infax[H-Empty]
{ \varnothing \quad caprod }

\infrule[H-Var]
{ G \; healthy \andalso T \; \text{capsafe} }
{ G, \; x:T \quad healthy }

\hfill\\

\end{multicols}
\end{framed}

\caption{System STLC-Impure Healthy Environment}
\label{fig:stlc-impure-healthy-definition}
\end{figure}

\emph{Why this formulation of healthy environment is acceptable?} We
need to ensure that all inhabitable types that can
appear in the pure environment can also appear in the healthy
environment. This claim has been formally proved:

\begin{theorem}[Inhabitable-Capsafe]
  If the type T is inhabitable, then either T is capsafe or $T = E$ or
  T is a free function type.
\end{theorem}

From the theorem above, it's obvious that a pure environment $\Gamma$
with only variables of inhabitable types is also a healthy
environment. Thus, any property proved for a healthy environment also
holds for $\Gamma$. It suffices to prove the statements about healthy
environments.

A consequence of this definition that a healthy environment is no
longer a pure environment. However, this is not a problem. We know
that a pure and inhabitable environment is a healthy environment, and
it's certainly true that \emph{a pure and inhabitable environment is
  also a pure and healthy environment}. Thus, we can define
$healthy' \; E := healthy \; E \wedge pure \; E = E$. Effect safety
proved only assuming \emph{healthy} also holds for $healthy'$. But
what's the purpose of defining such a weaker concept of
\emph{healthy}? The answer is that it makes the first statement of
effect safety simpler. As we'll see, the proof of the first statement
of effect safety only depends on \emph{healthy}, while the second
depends on \emph{healthy'}. Thus, we need a stronger version of the
second statement of effect safety:

\begin{definition}[Effect-Safety-2']
  If $\Gamma$ is healthy and pure, and $\Gamma \vdash t_1 \; t_2 : T$,
  then there exists U, V such that $\Gamma \vdash t_1 : U \to V$.
\end{definition}

As the statement \emph{Effect-Safety-1} and \emph{Effect-Safety-2'}
logically imply the statement \emph{Effect-Safety-Inhabitability-1}
and \emph{Effect-Safety-Inhabitability-2} respectively, it suffices to
prove the statement \emph{Effect-Safety-1} and
\emph{Effect-Safety-2'}.

\subsubsection{Proof}

The proof of the first statement of effect safety is almost the same
as in STLC-Pure. In the presence of subtyping, we need to add a lemma
\emph{Capsafe-Sub}.  The first effect safety statement follows
immediately from the lemma \emph{Healthy-Capsafe}.

\begin{lemma}[Capsafe-Not-Caprod]
 If type T is capsafe, then T is not caprod.
\end{lemma}

\begin{lemma}[Capsafe-Or-Caprod]
 For any T, T is either capsafe or caprod.
\end{lemma}

\begin{lemma}[Capsafe-Sub]
 If S is capsafe and $S <: T$, then T is capsafe.
\end{lemma}

\begin{lemma}[Healthy-Capsafe]
  If $\Gamma$ is healthy and $\Gamma \vdash t : T$, then T is capsafe.
\end{lemma}

\begin{theorem}[Effect-Safety-1]
  If $\Gamma$ is healhty, then there doesn't exist term $t$ with
  $\Gamma \vdash t : E$.
\end{theorem}

However, it's impossible to prove the second statement of effect
safety, which states that if we can construct an application
$t_1 \; t_2$ in a healthy and pure environment, then $t_1$ can be
typed as $S \to T$ for some S and T. To see an example why it cannot
be proved, let's assume
$\Gamma = \{f: B \to B \Rightarrow B, \; x: B\}$. It's obvious
$\Gamma$ is healthy and pure, however, $f \; x$ in the term
$(f \; x) \;x$ has the type $B \Rightarrow B$. And it's impossible to
prove that $f \; x$ has the type $B \to B$. If $f$ is not a variable,
but a fully defined function, then we can prove that $f$ also has the
type $B \to B \to B$. This is because the inner function of type
$B \Rightarrow B$ cannot capture any capabilities or free functions,
otherwise the outer function can't be typed as stoic!

This observation leads us to assume four well-founded axioms listed in
Figure~\ref{fig:stlc-impure-axioms}. These axioms can only be proved
if $\Gamma$ is empty\footnote{Except the axiom \textsc{Ax-Poly}, which
  cannot be proved even if $\Gamma$ is empty.}. Otherwise, if $t$ is a
variable, we can do nothing.

\begin{figure}[h]
\begin{framed}

% multi-column separator
% \setlength{\columnseprule}{0.4pt}
\begin{multicols}{2}

\infrule[Ax-Base]
{ \Gamma \vdash t : B \to S \Rightarrow T }
{ \Gamma \vdash t : B \to S \to T }

\hfill\\

\infrule[Ax-Top]
{ \Gamma \vdash t : Top \to S \Rightarrow T }
{ \Gamma \vdash t : Top \to S \to T }

\hfill\\

\infrule[Ax-Stoic]
{ \Gamma \vdash t : (U \to V) \to S \Rightarrow T }
{ \Gamma \vdash t : (U \to V) \to S \to T }

\hfill\\

\infrule[Ax-Poly]
{ \Gamma \vdash t_2 : U \to V \\
  \Gamma \vdash t_1 : (U \Rightarrow V) \to S \Rightarrow T }
{ \Gamma \vdash t_1 \; t_2 : S \to T }

\end{multicols}
\end{framed}

\caption{System STLC-Impure Axioms}
\label{fig:stlc-impure-axioms}
\end{figure}

The justification for the axiom \textsc{Ax-Base} is as
follows. Suppose $t = \lambda x:B. \; \lambda y:S. \; t_1$ and
$\Gamma \vdash t : B \to S \Rightarrow T$. The typing rule for $t$
should be the typing rule for stoic functions:

\infrule[Step-1]
{ pure(\Gamma),\; x: B \vdash \lambda y:S. \; t_1 : S \Rightarrow T }
{ \Gamma \vdash \lambda x:B. \lambda y:S. \; t_1 : B \to S \Rightarrow T }

Then what's the rule used in the typing of $\lambda y:S. \; t_1$? If
it's first typed as $S \to T$ and then subsumed as $S \Rightarrow T$,
then we are done. Otherwise, $\lambda y:S. \; t_1$ is typed using the
rule of free functions:

\infrule[Step-2]
{ pure(\Gamma),\; x: B,\; y:S \vdash t_1 : T }
{ pure(\Gamma),\; x: B \vdash \lambda y:S. \; t_1 : S \Rightarrow T }

According to the definition of \emph{pure}, we know that following two
equations holds:

\begin{center}
\begin{tabular}{l c l}
$pure(pure(\Gamma))$ & = & $pure(\Gamma)$ \\
$pure(\Gamma, x:B)$ & = & $pure(\Gamma), x:B$
\end{tabular}
\end{center}

From the equations above, we can get following equation:

\begin{center}
  $pure(pure(\Gamma),\; x: B) = pure(\Gamma),\; x: B$
\end{center}

If we substitute the equation in Step-2, we get exactly the
precondition for typing stoic functions. Thus $\lambda y:S.t_2$ can be
typed as stoic function:

\infrule[Step-2']
{ pure(pure(\Gamma),\; x: B),\; y:S \vdash t_1 : T }
{ pure(\Gamma),\; x: B \vdash \lambda y:S. \; t_1 : S \to T }

Because we know $\lambda y:S. \; t_1$ is typed as $S \to T$, so we can
update Step-1 as following:

\infrule[Step-1']
{ pure(\Gamma),\; x: B \vdash \lambda y:S. \; t_1 : S \to T }
{ \Gamma \vdash \lambda x:B. \lambda y:S. \; t_1 : B \to S \to T }

Put all the steps together, we obtained
$\Gamma \vdash t : B \to S \to T$ from the fact
$\Gamma \vdash t : B \to S \Rightarrow T$. That's the justification
for the \textsc{Ax-Base} rule. The justifications for \textsc{Ax-Top}
and \textsc{Ax-Stoic} are similar. The axiom \textsc{Ax-Poly} is an
interesting one, which deserves a separate section.

Assuming the axioms above, it's straight-forward to prove a lemma
\emph{Healthy-Pure-Stoic}, and the second statement of effect safety
follows immediately from the lemma.

\begin{lemma}[Healthy-Pure-Stoic]
  If $\Gamma$ is healthy and pure,  and $\Gamma \vdash t : S
  \Rightarrow T$, then $\Gamma \vdash t : S \to T$.
\end{lemma}

\begin{theorem}[Effect-Safety-2']
  If $\Gamma$ is healthy and pure, and $\Gamma \vdash t_1 \; t_2 :
  T$, then there exists U, V such that $\Gamma \vdash t_1 : U \to V$.
\end{theorem}

% Note that unlike the proof of the first effect safety statement, the
% proof of the second statement of effect safety assumes that $\Gamma$
% is pure. This is due to the fact that \emph{healthy} no longer implies
% \emph{pure}. Conceptually speaking, a healthy environment should
% always be a subset of pure environment. To clear the worry of readers,
% we can define $healthy' \; E := healthy \; E \wedge pure \; E = E$.
% The first statement of effect safety is proved only assuming the
% weaker \emph{healthy}, it certainly holds for $healthy'$ as well.

\subsection{Effect Polymorphism}

The axiom \textsc{Ax-Poly}, which we call \emph{effect polymorphism},
reflects some important property about capability-based effect
systems.

\infrule[Ax-Poly] { \Gamma \vdash t_2 : U \to V \andalso \Gamma \vdash
  t_1 : (U \Rightarrow V) \to S \Rightarrow T } { \Gamma \vdash t_1 \;
  t_2 : S \to T }


Suppose following typing relation holds, what impure
variables can be captured by $t_1$?

\begin{center}
  $\Gamma \vdash \lambda f:U \Rightarrow V. \; \lambda y:S. \; t_1 : (U
  \Rightarrow V) \to S \Rightarrow T$.
\end{center}

As the functioin is stoic, the only impure variable can be captured is
$f$. Now, if we supply a stoic function as parameter to the function,
it has the same effect as saying that $f$ is $U \to V$. Thus in this
context, the function can be typed as $(U \to V) \to S \Rightarrow T$.
Now according to the \textsc{Ax-Stoic} axiom, the term can also be
typed as $(U \to V) \to S \to T$. Then according to the standard
\textsc{T-App} rule, the type of the application is $S \to T$. That's
the justification for the axiom \textsc{Ax-Poly}.

Effect polymorphism is an advantage of capability-based effect systems
over monad-based effect systems. In Haskell, there is always the need
to maintain two copies of higher-order functions, as following code
snippet shows\footnote{From the slides of Ben Lippmeier,
  \emph{Witnessing Purity, Constancy and Mutability}, APLAS 2009}:

\begin{lstlisting}[language=Haskell]
  map :: (a -> b) -> List a -> List b
  map f xs
    = case xs of
        Nil -> Nil
        Cons x xs -> Cons (f x) (map f xs)

  mapIO :: (a -> IO b) -> List a -> IO (List b)
  mapIO f xs
    = case xs of
      Nil -> return Nil
      Cons x xs -> do x' <- f x
        xs' <- mapIO f xs
        return (Cons x' xs')
\end{lstlisting}

The non-monadic version and the monadic version of code are the same
in essence. It's a pity that we have to duplicate the same code twice
in monad-based effect systems. In capability-based effect systems, we
only need to maintain one copy of the code:

\begin{lstlisting}[language=Scala]
  def map[A,B](f: A => B)(l: List[A]) = l match {
    case Nil => Nil
    case x::xs => f(x)::map(f)(l)
  }
\end{lstlisting}
% haskell two versions of map

The \emph{map} function above has the type
$(A \Rightarrow B) \to List[A] \Rightarrow List[B]$. Is \emph{map} a
pure function? It depends on how it's used. When supplied with a
function of type $A \Rightarrow B$ with side effects, \emph{map} is
impure. When supplied with a pure function $f$ of type $A \to B$,
\emph{map} has the actual type $(A \to B) \to List [A] \to List[B]$,
thus is pure. Following code snippet demonstrates the usage of
\emph{map} in both pure and impure settings.

\begin{lstlisting}[language=Scala]
  def squareImpure(list: List[Int])(c: IO) = {
    map { x => println(x)(c); x*x } list
  }

  def squarePure(list: List[Int]) = {
    map { x => x*x } list
  }
\end{lstlisting}

In the code above, the lambda passed to \emph{map} in
\emph{squareImpure} is not stoic, as it captures the capability
$c$. The function \emph{squareImpure} has the type
$List[Int] \to IO \to List[Int]$, and \emph{squarePure} has the type
$List[Int] \to List[Int]$. This means all effects are captured in the
type system even in the presence of (local) free functions.

The reader might be wondering, what if we want to stipulate that the
passed function \emph{f} can only have IO effects? How does effect
polymorphism work in such cases? The answer is as follows:

\begin{lstlisting}[language=Scala]
  private def mapImpl[A,B](f: A => B)(l: List[A]) = l match {
    case Nil => Nil
    case x::xs => f(x)::map(f)(l)
  }

  def map[A,B](f: A -> B) = mapImpl(f)

  def map[A,B](c: IO)(f: IO -> A => B) = mapImpl(f c)
\end{lstlisting}

In the above, we only have one implementation of the \emph{map}
function and we protect the implementation with the keyword
\emph{private}. All callings of the \emph{map} function has to go
through the two exposed interface. The two interfaces imposes that the
passed function \emph{f} must either be pure or only have IO side
effects. And it's possible to add new interfaces to allow more effects
without breaking compatibility of existing code. This is the power and
flexibility of capability-based effect systems.
