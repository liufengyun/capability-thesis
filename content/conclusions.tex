\section{Conclusion}

We have formalized four capability-based effect systems and proved
soundness and effect safety for each system. The four systems can
serve as the theoretical foundation for implementing capability-based
effect systems in functional languages.

The existence of \emph{stoic functions} is the main trait of
capability-based effect systems. The interplay between \emph{stoic
  functions} and \emph{free functions} enables flexible programming
patterns that trivially solve the problem of \emph{effect
  polymorphism}.

Capability-based effect systems have to be paired with strict
evaluation, just like monad-based effect systems have to be paired
with lazy evaluation.

In the two proposed systems with universal types, namely F-Pure and
F-Impure, it's impossible to abstract over capability types and free
function types.

\subsection{Related Work}

Lucassen and Gifford first introduced type-and-effect
systems\cite{gifford1986integrating} and effect polymorphism using
effect type parameterization \cite{lucassen1988polymorphic}, which is
further developed by Talpin and Jouvelot to provide type-and-effect
inference \cite{talpin1992polymorphic,
  talpin1994type}. Type-and-effect inference can greatly reduce
verbosity in syntax, but it only works in languages with global type
inference, while Scala is based on local type inference. Even in those
languages with global type-and-effect inference, the type signature
for effect-polymorphic functions are much more complex than in
capability-based effect systems, which is an obstacle to programmers.

Moggi introduced the usage of monads for computation
effects\cite{moggi1991notions}. Wadler popularized the usage of
monads\cite{wadler1992comprehending, wadler1995monads} and proved that
it's possible to transpose any type-and-effect system into a
corresponding monad system\cite{wadler2003marriage}. Lippmeier
proposed the usage of region variables and dependently kinded witness
to encode mutability polymorphism\cite{lippmeier2009witnessing}.

Lukas \emph{et al.}  studied type-and-effect systems for
Scala\cite{rytz2012lightweight, rytz2013flow, lukas2014effect}.  In
lightweight polymorphic effects\cite{rytz2012lightweight}, the
dichotomy between \emph{effect-polymorphic function type} and
\emph{monomorphic function type} resembles the dichotomy between
\emph{stoic function type} and \emph{free function type}. However, in
the system effect polymorphism doesn't work for curried functions. To
overcome this problem, they unified the two function types in a
framework called \emph{relative effect annotation} based on dependent
types. They also implemented a plugin for the Scala compiler.

Heather \emph{et al.} proposed a special function type called
\emph{spores} for Scala\cite{miller2014spores}. Compared to normal
functions, spores observe a variable capturing discipline. The set of
types allowed or not allowed to be captured is part of the type
signature of spores, thus can be used by library authors to impose
constraints on parameters of function types. Spores are well suited
for distributed and parallel computations, but don't generalize to a
practical effect system.

Crary \emph{et al.} proposed a capability calculus for region-based
memory management\cite{crary1999typed}. The safety of deallocation of
memory can be guaranteed by the type system. In the capability
calculus, a capability is a set of regions that are presently valid to
access, in contrast to the abstract meaning of capabilities in our
systems. The difference is mainly due to the different focus of
effects under study.

\subsection{Future Work}

Objects and mutation are predominant features of industrial
languages. To provide a more practical model for industrial languages,
it's useful to extend existing systems with record types and mutation.

Effect masking can be a useful feature in real-world programming,
especially when dealing with exception effects. It's worthy to explore
effect masking in existing systems.

One approach to make parametric polymorphism work for capability types
and free function types is to integrate \emph{bounded quantification}
with capabilities. This is the what we are working on now. We've
managed to prove soundness of the system, and the proof of effect
safety is in progress.

% Another direction of work is to extend the proposed systems with some
% implicit calculus, in order to avoid explicitly passing capabilities
% around in the code. This would result in significant savings in
% boilerplate code, thus make the system more friendly to programmers.

% The most exciting work would be to implement a capability-based effect
% system in Scala or other industrial programming languages and
% popularize the usage of effect systems in the programming community.
