\section*{\centering Abstract}
\addcontentsline{toc}{section}{Abstract}

Type-and-effect systems have been around for about thirty years. But
they have never gained popularity in the programming community, mainly
due to the verbosity of its syntax. \emph{Monad-based} effect systems
have a successful story in Haskell, but these systems can't handle
\emph{effect polymorphism} well.  Haskell programmers often need to
maintain both a monadic and non-monadic version of the same code.

In this study we took another approach and investigated
\emph{capability-based} effect systems. In such systems, an instance
of capability type is required to make side effects. To ensure
capabilities are passed as function parameters, we introduced
\emph{stoic functions} which observe a \emph{variable-capturing
  discipline} , in contrast to \emph{free functions}, which have no
constraints in capturing variables.

Generally speaking, capability-based effect systems are easier to
understand and use than monad-based effect systems. More importantly,
equipped with stoic functions and free functions, capability-based
systems can handle \emph{effect polymorphism} elegantly. These merits
make capability-based effect systems stand a better chance to be
adopted by the programming community.

In this report we present four capability-based type-and-effect
systems of increasing complexity, namely STLC-Pure, STLC-Impure,
F-Pure and F-Impure.  The system SLTC-Pure and F-Pure demonstrated
that capability-based effect systems can be used in pure functional
languages to track effects. The system STLC-Impure and F-Impure
demonstrated that in a capability-based effect system with both free
functions and stoic functions, the problem of \emph{effect
  polymorphism} can be solved trivially.
