\section{Introduction}

The objective of this study is to explore the theoretical foundations
as well as conceptual possibilities of capability-based effect
systems. In this chapter, we'll discuss the motivation, the core ideas
and contributions of this study.

\subsection{Motivation}

The main motivation is to turn Scala into an effect-disciplined
programming language. Currently, Scala doesn't have the ability to
track effects in the type system. This poses a problem in distributed
and parallel computations. For example, in parallel computing, there's
often the need to stipulate that the functions passed to the function
\emph{pmap} have no side effects.

\begin{lstlisting}[language=Scala]
def pmap(xs: List[Int], f: Int => Int): List[Int]
\end{lstlisting}

However, currently it's impossible for the library author to impose
the constraint in the type system. The central problem in introducing
a practical effect system in Scala is how to handle the problem of
\emph{effect polymorphism}.

The problem of \emph{effect polymorphism} can be illustrated by the
function \emph{map}:

\begin{lstlisting}[language=Scala]
  def map[A,B](f: A => B)(l: List[A]) = l match {
    case Nil => Nil
    case x::xs => f(x)::map(f)(l)
  }
\end{lstlisting}

In an effect system, the effect of \emph{map} depends on the passed in
function \emph{f}. If \emph{f} has IO effects, then \emph{map} also
has IO effects. If \emph{f} is pure, then \emph{map} is pure as
well. The way to express effect polymorphism in classical
type-and-effect systems (such as \cite{lucassen1988polymorphic}) is to
introduce a new type variable E to denote the generic effect:

\begin{lstlisting}[language=Scala]
def map[A, B, E](f: A -> B @E)(l: List[A]): List[B] @E
\end{lstlisting}

A type-and-effect system has been proposed for
Scala\cite{lukas2014effect}, which avoids introducing a new type
variable for the generic effect:

\begin{lstlisting}[language=Scala]
def map[A, B](f: A -> B)(l: List[A]): List[B] @pure(f)
\end{lstlisting}

The annotation $@pure(f)$ says that the effect of \emph{map} depends
on the function \emph{f}. Despite the syntactical improvements, it
still incurs some notational burden on programmers, thus is not well
received in the Scala community.

Monad-based effect systems have a success in Haskell. However, as we
will explain, monad-based effect systems only work in lazy languages;
it is unsuitable for Scala because Scala is strict. On the other hand,
monad-based effect systems also face the problem of \emph{effect
  polymorphism}. As reported in Chapter 1 section 6 of the
thesis\cite{lippmeier2009type}, almost every general purpose
higher-order function in Haskell needs both a monadic version and
non-monadic version. For example, following code snippet shows the
signature for two versions of the \emph{map} function. The duplication
of code is a pity for programmers.

\begin{lstlisting}[language=Haskell]
  map :: (a -> b) -> List a -> List b
  mapIO :: (a -> IO b) -> List a -> IO (List b)
\end{lstlisting}

Given this situation, we are compelled to find a new approach to the
effect polymorphism problem, and \emph{capability-based} effect
systems seem to be a promising direction.

\subsection{Capability-based Effect Systems}

The central idea of \emph{capability-based} effect system is that an
instance of capability is required in order to make side effects. If
capabilities are passed as function parameters, by tracking
capabilities in the type system we can track effects in the program.

To ensure that capabilities are passed through function parameters,
instead of being captured from the environment, we need to impose a
\emph{variable-capturing discipline}, stipulating that capability
variables cannot be captured. Functions observe the discipline are
called \emph{stoic functions}, while functions don't observe the
discipline are called \emph{free functions}. We use $\to$ to denote
the type of stoic functions and $\Rightarrow$ to denote the type of
free functions. Following example shows that incorrect capturing of
capability variables in a stoic function will generate a typing error:

\begin{lstlisting}[language=Scala]
def map(xs: List[Int], f: Int => Int): List[Int]
def pmap(xs: List[Int], f: Int -> Int): List[Int]
def print(x: Any, c: IO): ()

def bar(xs: List[Int])(c: IO) =
    map(xs, { x => print(x, c); x })

def foo(xs: List[Int], c: IO) =
    pmap(xs, { x => print(x, c); x })    // Error, can't capture c
\end{lstlisting}

With the combination of free functions and stoic functions,
capability-based effect systems can solve the problem of \emph{effect
  polymorphism} easily, while incurring no syntactical burden. For
example, instead of having two versions of \emph{map}, only one
polymorphic implementation is required here:

\begin{lstlisting}[language=Scala]
  private def mapImpl[A,B](f: A => B)(l: List[A]) = l match {
    case Nil => Nil
    case x::xs => f(x)::map(f)(l)
  }

  def map[A,B](f: A -> B) = mapImpl(f)

  def map[A,B](c: IO)(f: IO -> A => B) = mapImpl(f c)
\end{lstlisting}

This example shows that the function \emph{f} passed to the two
\emph{map}s must be pure or only have IO effects. The type system
ensures that the first \emph{map} is typed as pure while the second
\emph{map} can only have IO effects, and both are stoic
functions. It's straight-forward to add a new \emph{map} interface to
allow exception effects without changing the implementation. If the
library author doesn't care what effects there might be, he can expose
the function \emph{mapImpl} directly to users.  We'll see details of
effect polymorphism in the system STLC-Impure in Section
\ref{sec:effect-polymorphism}.

\subsection{Contributions}

The main contributions of this study are as follows:

\begin{itemize}
\item We formulated and proved soundness and effect safety of four
  capability-based effect systems, which can serve as the foundation
  for implementing capability-based effect system in functional
  programming languages. The formalization is done in Coq based on the
  locally-nameless representation\cite{chargueraud-11-ln} and hosted
  on github\footnote{\url{https://github.com/liufengyun/stoic}}.
\item We proposed an approach to solve the problem of \emph{effect
    polymorphism} in capability-based effect systems with both free
  functions and stoic functions (Section
  \ref{sec:effect-polymorphism}), which is simpler than in
  type-and-effect systems and monad-based effect systems.
\end{itemize}

\subsection{Structure of Report}

In following chapters, we'll introduce four systems of increasing
complexity, namely STLC-Pure, STLC-Impure, F-Pure and F-Impure. The
latter three is a gradual enrichment of STLC-Pure with free functions,
subtyping and universal types.

\begin{itemize}
\item STLC-Pure is an variant of \emph{simply typed lambda-calculus}
  with only stoic functions.
\item STLC-Impure is an extension of STLC-Pure with free functions and subtyping.
\item F-Pure is an extension of STLC-Pure with universal types.
\item F-Impure is an extension of F-Pure with free functions.
\end{itemize}

We discuss \emph{effect polymorphism} in the chapter STLC-Impure
(Section \ref{sec:effect-polymorphism}).
