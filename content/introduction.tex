\section{Introduction}

% The objective of this study is to explore the theoretical foundations
% as well as conceptual possibilities of capability-based effect
% systems.

% In this chapter, we'll discuss the motivation, the core ideas and
% contributions of this study.

% \subsection{Motivation}

The main motivation of this study is to turn Scala into an
effect-disciplined programming language. Currently, Scala doesn't have
the ability to track effects in the type system.

The absence of an effect system deprives programmers of the freedom to
impose effect constraints on APIs in parallel and distributed
computations. For example, in parallel computing, there's often the
need to stipulate that the functions passed to the function
\emph{pmap} have no side effects, which is currently impossible in
Scala:

\begin{lstlisting}[language=Scala]
def pmap(xs: List[Int], f: Int => Int): List[Int]
\end{lstlisting}

An effect system can differentiate pure code from impure code in a
program, thus enables optimization of pure code. For example,
independent pure expressions can be executed in parallel; pure code
that is dead can be safely eliminated; common pure expressions can be
reduce to one computation; pure operations on data structures can be
fused\cite{coutts2007stream}. The absence of an effect system makes
these optimizations impossible.

The central problem in introducing a practical effect system in Scala
is how to handle the problem of \emph{effect polymorphism}.

\subsection{Effect Polymorphism}

\emph{Effect polymorphism} can be illustrated by the
function \emph{map}:

\begin{lstlisting}[language=Scala]
  def map[A,B](f: A => B)(l: List[A]) = l match {
    case Nil => Nil
    case x::xs => f(x)::map(f)(xs)
  }
\end{lstlisting}

In an effect system, the effect of \emph{map} depends on the passed in
function \emph{f}. If \emph{f} has IO effects, then \emph{map} also
has IO effects. If \emph{f} is pure, then \emph{map} is pure as
well. The way to express effect polymorphism in classical
type-and-effect systems is to introduce a new type variable E to
denote the generic effect:

\begin{lstlisting}[language=Scala]
def map[A, B, E](f: A => B @E)(l: List[A]): List[B] @E
\end{lstlisting}

Java, the only industrial language integrated with an effect system
for checked exceptions, exemplifies the classical approach to effect
polymorphism:

\begin{lstlisting}[language=Java]
  public interface FunctionE<T, U, E extends Exception> {
    public U apply(T t) throws E;
  }
  public interface List<T> {
    public <U, E extends Exception> List<U>
           mapE(FunctionE<T, U, E> f) throws E;
  }
\end{lstlisting}

Due to the verbosity of syntax, effect polymorphism is rarely used in
Java, which reduces the effectiveness of the effect system.

The problem of effect polymorphism is how to express
effect-polymorphic functions with minimal syntactical overhead.
\emph{Capability-based} effect systems provide an elegant solution to
this problem.

\subsection{Capability-Based Effect Systems}

The central idea of \emph{capability-based} effect system is that an
instance of capability is required in order to make side effects. If
capabilities are passed as function parameters, by tracking
capabilities in the type system we can track effects in the program.

To ensure that capabilities are passed through function parameters,
instead of being captured from the environment, we need to impose a
\emph{variable-capturing discipline}, stipulating that capability
variables cannot be captured. Functions observe the discipline are
called \emph{stoic functions}, while functions don't observe the
discipline are called \emph{free functions}. We use $\to$ to denote
the type of stoic functions and $\Rightarrow$ to denote the type of
free functions. Following example shows that incorrect capturing of
capability variables in a stoic function will generate a typing error:

\begin{lstlisting}[language=Scala]
def map(xs: List[Int], f: Int => Int): List[Int]
def pmap(xs: List[Int], f: Int -> Int): List[Int]
def print(x: Any, c: IO): ()

def bar(xs: List[Int])(c: IO) =
    map(xs, { x => print(x, c); x })

def foo(xs: List[Int], c: IO) =
    pmap(xs, { x => print(x, c); x })    // Error, can't capture c
\end{lstlisting}

With the combination of free functions and stoic functions,
capability-based effect systems can solve the problem of \emph{effect
  polymorphism} easily, while incurring no syntactical overhead. For
example, the effect-polymorphic function \emph{map} can be implemented
as follows:

\begin{lstlisting}[language=Scala]
  private def mapImpl[A,B](f: A => B)(l: List[A]) = l match {
    case Nil => Nil
    case x::xs => f(x)::map(f)(xs)
  }

  def map[A,B](f: A -> B) = mapImpl(f)

  def map[A,B](c: IO)(f: IO -> A => B) = mapImpl(f c)
\end{lstlisting}

This example shows that the function \emph{f} passed to the two
\emph{map}s must be either pure or only have IO effects. The type
system ensures that the first \emph{map} is typed as pure while the
second \emph{map} can only have IO effects, and both are stoic
functions. It's straight-forward to add a new \emph{map} interface to
allow exception effects without changing the implementation. If the
library author doesn't care what effects there might be, he can expose
the function \emph{mapImpl} directly to users.  We'll see details of
effect polymorphism in the system STLC-Impure in Section
\ref{sec:effect-polymorphism}.

\subsection{Contributions}

The main contributions of this study are as follows:

\begin{itemize}
\item We formulated and proved soundness and effect safety of four
  capability-based effect systems, which can serve as the foundation
  for implementing capability-based effect system in functional
  programming languages. The formalization is done in Coq based on the
  locally-nameless representation\cite{chargueraud-11-ln} and hosted
  on github\footnote{\url{https://github.com/liufengyun/stoic}}.
\item We proposed an approach to solve the problem of \emph{effect
    polymorphism} with no syntactical overhead, thanks to free
  functions and stoic functions (Section
  \ref{sec:effect-polymorphism}).
\end{itemize}

\subsection{Structure of Report}

In following chapters, we'll introduce four systems of increasing
complexity, namely STLC-Pure, STLC-Impure, F-Pure and F-Impure. The
latter three is a gradual enrichment of STLC-Pure with free functions,
subtyping and universal types.

\begin{itemize}
\item STLC-Pure is a variant of \emph{simply typed lambda calculus}
  with only stoic functions.
\item STLC-Impure is an extension of STLC-Pure with free functions and subtyping.
\item F-Pure is an extension of STLC-Pure with universal types.
\item F-Impure is an extension of F-Pure with free functions.
\end{itemize}

We discuss \emph{effect polymorphism} in the chapter STLC-Impure
(Section \ref{sec:effect-polymorphism}).
